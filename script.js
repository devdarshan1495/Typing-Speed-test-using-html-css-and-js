
        // All JavaScript from the previous FULL version
        // with the only key changes being to:
        // 1. `textTypeToggleButton` event listener for `testConfig.textSource`
        // 2. `generateTestWordsArray` using `testConfig.textSource`
        // 3. `endGame` recording `testConfig.textSource` in history.
        // 4. Backspace logic refined in `hiddenInput.addEventListener('keydown', ...)`

        document.addEventListener('DOMContentLoaded', () => {
            const body = document.body;
            const themeSwitcher = document.getElementById('themeSwitcher');
            const wordsContainer = document.getElementById('wordsContainer');
            const hiddenInput = document.getElementById('hidden-input');
            const caret = document.getElementById('caret');
            const timeLeftDisplay = document.getElementById('timeLeft');
            const wpmDisplay = document.getElementById('wpm');
            const accuracyDisplay = document.getElementById('accuracy');
            const statsDisplay = document.getElementById('statsDisplay');
            const restartTestBtn = document.getElementById('restartTestBtn');
            const resultsOverlay = document.getElementById('resultsOverlay');
            const resultWPM = document.getElementById('resultWPM');
            const resultAcc = document.getElementById('resultAcc');
            const resultRawWPM = document.getElementById('resultRawWPM');
            const resultChars = document.getElementById('resultChars');
            const resultMode = document.getElementById('resultMode');
            const resultsRestartBtn = document.getElementById('resultsRestartBtn');
            const resultTitle = document.getElementById('resultTitle');
            
            const pageLinks = document.querySelectorAll('.page-link'); // No actual links in this fullscreen version now
            const pageContents = document.querySelectorAll('.page-content');
            const logoLinkContainer = document.getElementById('logoLinkContainer'); 

            const configButtons = document.querySelectorAll('.config-button');
            const textTypeToggleButton = document.getElementById('textTypeToggle');

            const statsHistoryList = document.getElementById('statsHistoryList');
            const avgWPMEl = document.getElementById('avgWPM');
            const avgAccEl = document.getElementById('avgAcc');
            const testsTakenEl = document.getElementById('testsTaken');
            const noHistoryMsg = document.getElementById('noHistoryMsg');
            const clearHistoryBtn = document.getElementById('clearHistoryBtn');

            let testConfig = { type: 'time', value: 30, textSource: 'words' }; 
            let currentWordElements = []; let currentLetterIndex = 0; let currentWordIndex = 0;
            let testTextWordsArray = []; let testActive = false; let timerInterval;
            let timeElapsed = 0; let typedCharsCount = 0; let correctCharsCount = 0;
            let totalCharsInCurrentTestText = 0; let startTime;
            let testHistory = JSON.parse(localStorage.getItem('proTypistXHistory_v4')) || [];
            const MAX_HISTORY_ITEMS = 25;

            const commonWords = ["the","be","to","of","and","a","in","that","have","I","it","for","not","on","with","he","as","you","do","at","this","but","his","by","from","they","we","say","her","she","or","an","will","my","one","all","would","there","their","what","so","up","out","if","about","who","get","which","go","me","when","make","can","like","time","no","just","him","know","take","people","into","year","your","good","some","could","them","see","other","than","then","now","look","only","come","its","over","think","also","back","after","use","two","how","our","work","first","well","way","even","new","want","because","any","these","give","day","most","us","get","has","her","make","out","say","see","she","so","some","take","tell","than","that","the","their","them","then","there","these","they","this","time","to","too","under","until","up","very","was","we","were","what","when","where","which","while","who","whom","why","with","would","you","your","yours","yourself","yourselves", "computer", "keyboard", "programming", "language", "function", "variable", "developer", "software", "application", "internet", "website", "interface", "algorithm", "database", "server", "client", "network", "security", "encryption", "framework", "library", "module", "component", "responsive", "design", "layout", "gradient", "animation", "transition", "javascript", "python", "java", "swift", "kotlin", "ruby", "pearl", "system", "process", "data", "information", "analysis", "strategy", "management", "organization", "business", "market", "product", "service", "customer", "quality", "performance", "efficiency", "improvement", "innovation", "technology", "digital", "communication", "collaboration", "leadership", "teamwork", "creativity", "problem", "solution", "challenge", "opportunity", "growth", "development", "future", "global", "world", "earth", "nature", "environment", "sustainability", "energy", "health", "education", "science", "research", "discovery", "knowledge", "wisdom", "philosophy", "history", "culture", "art", "music", "literature", "society", "community", "family", "friendship", "love", "happiness", "life", "death", "meaning", "purpose", "value", "ethics", "morality", "justice", "freedom", "equality", "humanity", "peace", "conflict", "war", "politics", "government", "economy", "finance", "money", "investment", "trade", "industry", "agriculture", "transportation", "infrastructure", "city", "country", "continent", "ocean", "mountain", "river", "forest", "desert", "animal", "plant", "weather", "climate", "space", "universe", "galaxy", "star", "planet", "moon", "sun", "light", "darkness", "day", "night", "morning", "afternoon", "evening", "second", "minute", "hour", "week", "month"];
            const shortQuotes = [ "The only way to do great work is to love what you do.", "Strive not to be a success, but rather to be of value.", "The mind is everything. What you think you become.", "Your time is limited, so don't waste it living someone else's life.", "The purpose of our lives is to be happy.", "Get busy living or get busy dying.", "You only live once, but if you do it right, once is enough.", "Many of life's failures are people who did not realize how close they were to success when they gave up.", "If you want to live a happy life, tie it to a goal, not to people or things.", "Never let the fear of striking out keep you from playing the game.", "The best way to predict the future is to create it.", "Do not go where the path may lead, go instead where there is no path and leave a trail.", "In the end, it's not the years in your life that count. It's the life in your years.", "The journey of a thousand miles begins with a single step.", "What you get by achieving your goals is not as important as what you become by achieving your goals." ];

            function applyTheme(themeName) { body.dataset.theme = themeName; localStorage.setItem('proTypistXTheme', themeName); if (themeSwitcher) themeSwitcher.value = themeName; }
            if (themeSwitcher) { themeSwitcher.addEventListener('change', (e) => applyTheme(e.target.value)); const savedTheme = localStorage.getItem('proTypistXTheme'); applyTheme(savedTheme || 'dracula'); }

            // Simplified Page "Navigation" - Only show typing test initially for this fullscreen version.
            // Stats History would need a separate view/modal trigger if not using traditional nav links.
            // For now, stats history logic is present but won't be shown without explicit navigation.
            // if(logoLinkContainer) logoLinkContainer.addEventListener('click', (e) => { e.preventDefault(); /* Can go to typing test if multiple "pages" existed */ initTest(); }); 

            function showPage(pageId) { pageContents.forEach(content => content.classList.toggle('active', content.id === pageId)); /* For navLinks styling */ pageLinks.forEach(link => link.classList.toggle('active', link.getAttribute('href').substring(1) === pageId)); if (pageId === 'typingTest') initTest(); if (pageId === 'statsHistory') renderStatsHistory(); }
            
            function updateConfigButtonStyles() { configButtons.forEach(btn => btn.classList.remove('active')); const activeBtn = Array.from(configButtons).find(btn => btn.id !== 'textTypeToggle' && btn.dataset.mode === testConfig.type && parseInt(btn.dataset.value) === testConfig.value ); if (activeBtn) activeBtn.classList.add('active'); if (textTypeToggleButton) { textTypeToggleButton.innerHTML = testConfig.textSource === 'words' ? '<i class="ri-text"></i> Words' : '<i class="ri-double-quotes-l"></i> Quotes'; }}
            configButtons.forEach(btn => { if (btn.id === 'textTypeToggle') return; btn.addEventListener('click', () => { testConfig.type = btn.dataset.mode; testConfig.value = parseInt(btn.dataset.value); updateConfigButtonStyles(); initTest(); }); });
            if (textTypeToggleButton) { textTypeToggleButton.addEventListener('click', () => { testConfig.textSource = testConfig.textSource === 'words' ? 'quotes' : 'words'; updateConfigButtonStyles(); initTest(); });}

            function generateTestWordsArray() { let words = []; const numWordsDefaultTime = 100; const numWordsConfig = testConfig.type === 'words' ? testConfig.value : numWordsDefaultTime; if (testConfig.textSource === 'quotes') { let quoteText = ""; while(quoteText.split(' ').length < 5 && quoteText.split(' ').length > 30) { /* ensure reasonable quote length for test */} quoteText = shortQuotes[Math.floor(Math.random() * shortQuotes.length)]; words = quoteText.split(' ');} else { for (let i = 0; i < numWordsConfig; i++) { words.push(commonWords[Math.floor(Math.random() * commonWords.length)]); }} return words; }
            function displayWords() { wordsContainer.innerHTML = ''; currentWordElements = []; totalCharsInCurrentTestText = 0; testTextWordsArray.forEach((wordStr) => { const wordEl = document.createElement('div'); wordEl.className = 'word'; const letters = []; wordStr.split('').forEach(char => { const letterEl = document.createElement('span'); letterEl.className = 'letter'; letterEl.textContent = char; wordEl.appendChild(letterEl); letters.push(letterEl); totalCharsInCurrentTestText++; }); const spaceEl = document.createElement('span'); spaceEl.className = 'letter'; spaceEl.innerHTML = 'Â '; spaceEl.style.opacity = '0'; wordEl.appendChild(spaceEl); letters.push(spaceEl); totalCharsInCurrentTestText++; wordsContainer.appendChild(wordEl); currentWordElements.push(letters); }); currentWordIndex = 0; currentLetterIndex = 0; positionCaret(); }
            function positionCaret() { if (!currentWordElements || currentWordElements.length === 0 || currentWordIndex >= currentWordElements.length) { caret.style.left = '0px'; caret.style.top = wordsContainer.firstElementChild ? wordsContainer.firstElementChild.offsetTop + 'px' : '0px'; return; } const currentWordSpans = currentWordElements[currentWordIndex]; let targetLetterSpan; if (currentLetterIndex < currentWordSpans.length) { targetLetterSpan = currentWordSpans[currentLetterIndex]; caret.style.left = targetLetterSpan.offsetLeft + 'px'; caret.style.top = targetLetterSpan.offsetTop + 'px'; } else { targetLetterSpan = currentWordSpans[currentWordSpans.length - 2]; if(targetLetterSpan){ caret.style.left = (targetLetterSpan.offsetLeft + targetLetterSpan.offsetWidth) + 'px'; caret.style.top = targetLetterSpan.offsetTop + 'px'; } else { const wordDiv = wordsContainer.children[currentWordIndex]; if(wordDiv){ caret.style.left = wordDiv.offsetLeft + 'px'; caret.style.top = wordDiv.offsetTop + 'px';}}} scrollWordsToCaret(); }
            function scrollWordsToCaret() { if (caret.offsetTop + caret.offsetHeight > wordsContainer.clientHeight + wordsContainer.scrollTop) { wordsContainer.scrollTop = caret.offsetTop + caret.offsetHeight - wordsContainer.clientHeight + 5;} else if (caret.offsetTop < wordsContainer.scrollTop) { wordsContainer.scrollTop = caret.offsetTop - 5;} }
            
            function applyStatUpdateAnimation(element) { if (!element) return; element.style.transition = 'none'; element.style.opacity = '0.5'; element.style.transform = 'translateY(3px)'; setTimeout(() => { element.style.transition = 'opacity 0.2s ease, transform 0.2s ease'; element.style.opacity = '1'; element.style.transform = 'translateY(0)'; }, 0); }

            hiddenInput.addEventListener('keydown', (e) => { if (!testActive && e.key !== 'Tab' && e.key !== 'Shift' && !e.metaKey && !e.ctrlKey && e.key.length === 1 && e.key !== 'Dead') { startGame(); } if (!testActive && !(e.key === 'Tab' || e.key === 'Shift')) { e.preventDefault(); return; } if(testActive) e.preventDefault(); else return; if (e.key === ' ') { if (currentLetterIndex === 0 && currentWordElements[currentWordIndex] && currentWordElements[currentWordIndex].length > 1 ) return; const currentWordSpans = currentWordElements[currentWordIndex]; for(let i=currentLetterIndex; i<currentWordSpans.length-1; i++){ typedCharsCount++; currentWordSpans[i].classList.remove('correct'); currentWordSpans[i].classList.add('incorrect'); currentWordSpans[i].style.animation = 'flashRed 0.3s'; setTimeout(()=> currentWordSpans[i].style.animation = '', 300); } typedCharsCount++; currentWordIndex++; currentLetterIndex = 0; if (currentWordIndex >= testTextWordsArray.length || (testConfig.type === 'words' && currentWordIndex >= testConfig.value) ) { endGame(); } } else if (e.key === 'Backspace') { if (currentLetterIndex > 0) { currentLetterIndex--; currentWordElements[currentWordIndex][currentLetterIndex].className = 'letter'; typedCharsCount = Math.max(0, typedCharsCount -1); /* A simple correction attempt */ } } else if (e.key.length === 1 && e.key !== 'Dead' && currentWordIndex < currentWordElements.length && currentLetterIndex < currentWordElements[currentWordIndex].length -1) { const expectedChar = currentWordElements[currentWordIndex][currentLetterIndex].textContent; typedCharsCount++; if (e.key === expectedChar) { currentWordElements[currentWordIndex][currentLetterIndex].className = 'letter correct'; correctCharsCount++; } else { currentWordElements[currentWordIndex][currentLetterIndex].className = 'letter incorrect'; } currentLetterIndex++; } positionCaret(); updateLiveStats(); });
            wordsContainer.addEventListener('click', () => hiddenInput.focus());
            
            function startGame() { if (testActive) return; testActive = true; timeElapsed = 0; typedCharsCount = 0; correctCharsCount = 0; startTime = new Date(); if(statsDisplay) {statsDisplay.classList.add('visible');} if(caret) caret.classList.add('visible'); if (resultsOverlay) resultsOverlay.classList.remove('visible'); if (testConfig.type === 'time') { if(timerInterval) clearInterval(timerInterval); timerInterval = setInterval(updateTimer, 1000); if (timeLeftDisplay) timeLeftDisplay.textContent = testConfig.value; } else { if (timeLeftDisplay) timeLeftDisplay.textContent = `0/${testConfig.value}`; } updateLiveStats(); if (hiddenInput) hiddenInput.focus(); document.querySelectorAll('.test-config-bar button, .navbar').forEach(el => {if(el) el.style.opacity = '0.6'}); }
            function updateTimer() { timeElapsed++; let remaining = testConfig.value - timeElapsed; if (timeLeftDisplay && testConfig.type === 'time') timeLeftDisplay.textContent = remaining > 0 ? remaining : 0; if (testConfig.type === 'time' && timeElapsed >= testConfig.value) { endGame(); } updateLiveStats(); }
            function updateLiveStats() { if (!testActive && timeElapsed === 0 && typedCharsCount === 0) { if (wpmDisplay) wpmDisplay.textContent = "0"; if(accuracyDisplay) accuracyDisplay.textContent = "100"; return;} const currentTime = new Date(); const currentElapsedTimeSeconds = testConfig.type === 'time' ? timeElapsed : (startTime ? (currentTime - startTime) / 1000 : 0); let wpmCalc = 0; if (currentElapsedTimeSeconds > 0.5) { wpmCalc = Math.round((correctCharsCount / 5) / (currentElapsedTimeSeconds / 60));} if (wpmDisplay) { if(wpmDisplay.textContent !== wpmCalc.toString()){wpmDisplay.textContent = wpmCalc; applyStatUpdateAnimation(wpmDisplay.parentElement || wpmDisplay);}} const acc = typedCharsCount > 0 ? Math.round((correctCharsCount / typedCharsCount) * 100) : ( (testActive || typedCharsCount > 0) ? 0 : 100); if (accuracyDisplay) { if(accuracyDisplay.textContent !== acc.toString()){ accuracyDisplay.textContent = acc; applyStatUpdateAnimation(accuracyDisplay.parentElement || accuracyDisplay);}} if(testConfig.type === 'words' && timeLeftDisplay){timeLeftDisplay.textContent = `${currentWordIndex}/${testConfig.value}`;} }
            
            function endGame() { if (!testActive) return; testActive = false; clearInterval(timerInterval); if (hiddenInput) hiddenInput.blur(); if(caret) caret.classList.remove('visible'); const finalTime = testConfig.type === 'time' ? testConfig.value : (startTime ? (new Date() - startTime) / 1000 : 0.001); const finalWPM = finalTime > 0 ? Math.round((correctCharsCount / 5) / (finalTime / 60)) : 0; const rawWPM = finalTime > 0 ? Math.round((typedCharsCount / 5) / (finalTime / 60)) : 0; const finalAccuracy = typedCharsCount > 0 ? Math.round((correctCharsCount / typedCharsCount) * 100) : 0; if(resultTitle) resultTitle.textContent = finalWPM >= 70 ? "Amazing Speed!" : (finalWPM >= 50 ? "Great Job!" : (finalWPM >=30 ? "Good Progress!" : "Keep Practicing!")); if(resultWPM) resultWPM.textContent = finalWPM; if(resultAcc) resultAcc.textContent = finalAccuracy; if(resultRawWPM) resultRawWPM.textContent = rawWPM; if(resultChars) resultChars.textContent = `${correctCharsCount}/${typedCharsCount}/${totalCharsInCurrentTestText}`; if(resultMode) resultMode.textContent = `${testConfig.type.charAt(0).toUpperCase() + testConfig.type.slice(1)}: ${testConfig.value}${testConfig.type === 'time' ? 's' : 'w'} (${testConfig.textSource.charAt(0).toUpperCase() + testConfig.textSource.slice(1)})`; if(resultsOverlay) resultsOverlay.classList.add('visible'); document.querySelectorAll('.test-config-bar button, .navbar').forEach(el => {if(el)el.style.opacity = '1'}); 
                const testResult = { wpm: finalWPM, acc: finalAccuracy, raw: rawWPM, chars: `${correctCharsCount}/${typedCharsCount}`, mode: `${testConfig.type.charAt(0).toUpperCase() + testConfig.type.slice(1)}: ${testConfig.value}${testConfig.type === 'time' ? 's' : 'w'} (${testConfig.textSource.charAt(0).toUpperCase() + testConfig.textSource.slice(1)})`, date: new Date().toISOString() };
                testHistory.unshift(testResult); if (testHistory.length > MAX_HISTORY_ITEMS) testHistory.pop(); localStorage.setItem('proTypistXHistory_v4', JSON.stringify(testHistory));
            }
            function initTest() { clearInterval(timerInterval); testActive = false; if(statsDisplay) statsDisplay.classList.remove('visible'); if(resultsOverlay) resultsOverlay.classList.remove('visible'); if(hiddenInput) { hiddenInput.value = ''; hiddenInput.focus(); } if(caret) caret.classList.remove('visible'); testTextWordsArray = generateTestWordsArray(); displayWords(); timeElapsed = 0; typedCharsCount = 0; correctCharsCount = 0; if (testConfig.type === 'time') { if(timeLeftDisplay) timeLeftDisplay.textContent = testConfig.value; } else { if(timeLeftDisplay) timeLeftDisplay.textContent = `0/${testConfig.value}`; } if(wpmDisplay) wpmDisplay.textContent = "0"; if(accuracyDisplay) accuracyDisplay.textContent = "100"; updateConfigButtonStyles(); positionCaret(); document.querySelectorAll('.test-config-bar button, .navbar').forEach(el => {if(el)el.style.opacity = '1'});}
            
            if(restartTestBtn) restartTestBtn.addEventListener('click', initTest);
            if(resultsRestartBtn) resultsRestartBtn.addEventListener('click', () => { if(resultsOverlay) resultsOverlay.classList.remove('visible'); initTest(); });
            if(wordsContainer) wordsContainer.addEventListener('click', () => {if(hiddenInput) hiddenInput.focus()});

            function renderStatsHistory() { /* ... */ if (!statsHistoryList || !avgWPMEl || !avgAccEl || !testsTakenEl) return; const history = JSON.parse(localStorage.getItem('proTypistXHistory_v4')) || []; statsHistoryList.innerHTML = ''; if (history.length === 0) { if (noHistoryMsg) { noHistoryMsg.style.display = 'list-item'; } avgWPMEl.textContent = '--'; avgAccEl.textContent = '--'; testsTakenEl.textContent = '0'; return; } if (noHistoryMsg) noHistoryMsg.style.display = 'none'; let totalWPM = 0, totalAcc = 0; history.forEach((item, index) => { const li = document.createElement('li'); li.style.animationDelay = `${index * 0.05}s`; li.innerHTML = `<span class="stat-date">${new Date(item.date).toLocaleDateString()} ${new Date(item.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span> <div class="stat-values"> <span>WPM: <strong>${item.wpm}</strong></span> <span>Acc: <strong>${item.acc}%</strong></span> <span>Raw: ${item.raw}</span> <span>Mode: ${item.mode}</span> </div>`; statsHistoryList.appendChild(li); totalWPM += Number(item.wpm) || 0; totalAcc += Number(item.acc) || 0; }); avgWPMEl.textContent = Math.round(totalWPM / history.length) || '--'; avgAccEl.textContent = Math.round(totalAcc / history.length) || '--'; testsTakenEl.textContent = history.length; }
            if(clearHistoryBtn) clearHistoryBtn.addEventListener('click', () => { if(confirm("Clear all test history? This cannot be undone.")){ localStorage.removeItem('proTypistXHistory_v4'); testHistory = []; renderStatsHistory(); }});
            
            initTest();
            showPage('typingTest'); // Initially, only show typing test page
                                     // If you add nav links back, this might change
        });
